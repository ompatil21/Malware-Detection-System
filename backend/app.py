from flask import Flask, jsonify, request
from flask_bcrypt import Bcrypt
from flask_jwt_extended import (
    JWTManager,
    create_access_token,
    jwt_required,
    get_jwt_identity,
)
from pymongo import MongoClient
from flask_cors import CORS
from datetime import datetime, timedelta
from werkzeug.utils import secure_filename
import os
import joblib
import pandas as pd
from sklearn.preprocessing import StandardScaler
import logging


app = Flask(__name__)

# Allow CORS for all routes, specifically allowing requests from http://localhost:3000
CORS(app, resources={r"/*": {"origins": "http://localhost:3000"}})

# JWT Configuration
app.config["JWT_SECRET_KEY"] = (
    "bd667fcbf4738fa009af7334d6b95ecb493a6d06625cc8fba4d52abc623a037f"
)
app.config["JWT_ACCESS_TOKEN_EXPIRES"] = timedelta(hours=1)

# Initialize extensions
bcrypt = Bcrypt(app)
jwt = JWTManager(app)

# Connect to MongoDB
client = MongoClient("mongodb://localhost:27017/")
db = client["trojan_detection"]

# File upload configuration
UPLOAD_FOLDER = "uploads"
os.makedirs(UPLOAD_FOLDER, exist_ok=True)
app.config["UPLOAD_FOLDER"] = UPLOAD_FOLDER


# Load the trained models and scaler
try:
    rf_model = joblib.load("tuned_trojan_detection_rf_model.pkl")  # Random Forest model
    scaler = joblib.load("scaler.pkl")  # Scaler
    logging.info("Model and Scaler loaded successfully.")
except Exception as e:
    logging.error(f"Error loading model or scaler: {str(e)}")
    raise e

ALLOWED_EXTENSIONS = {"csv"}


def allowed_file(filename):
    return "." in filename and filename.rsplit(".", 1)[1].lower() in ALLOWED_EXTENSIONS


@app.route("/")
def home():
    return "Welcome to the Flask API!"


@app.route("/api/signup", methods=["POST"])
def signup():
    email = request.json.get("email")
    password = request.json.get("password")
    role = request.json.get("role")
    name = request.json.get("name")
    username = request.json.get("username")

    if db.users.find_one({"email": email}):
        return jsonify({"message": "Email already exists"}), 400

    hashed_password = bcrypt.generate_password_hash(password).decode("utf-8")
    db.users.insert_one(
        {
            "username": username,
            "password": hashed_password,
            "role": role,
            "name": name,
            "email": email,
            "disabled": False,
            "created_at": datetime.now(),
            "updated_at": datetime.now(),
        }
    )

    return jsonify({"message": f"{role.capitalize()} created successfully"}), 201


@app.route("/api/login", methods=["POST"])
def login():
    email = request.json.get("email")
    password = request.json.get("password")
    role = request.json.get("role")

    user = db.users.find_one({"email": email, "role": role})

    if not user or not bcrypt.check_password_hash(user["password"], password):
        return jsonify({"message": "Invalid email, password, or role"}), 401

    access_token = create_access_token(identity={"email": email, "role": role})
    return jsonify({"token": access_token, "role": role}), 200


@app.route("/api/profile", methods=["GET"])
@jwt_required()
def get_profile():
    current_user = get_jwt_identity()
    user = db.users.find_one(
        {"email": current_user["email"]}, {"_id": 0, "password": 0}
    )

    if not user:
        return jsonify({"message": "User not found"}), 404

    return jsonify(user), 200


@app.route("/api/profile", methods=["PUT"])
@jwt_required()
def update_profile():
    current_user = get_jwt_identity()
    user = db.users.find_one({"username": current_user["username"]})

    if not user:
        return jsonify({"message": "User not found"}), 404

    updated_data = {
        "name": request.json.get("name", user["name"]),
        "email": request.json.get("email", user["email"]),
        "updated_at": datetime.now(),
    }

    db.users.update_one({"username": current_user["username"]}, {"$set": updated_data})
    return jsonify({"message": "Profile updated successfully"}), 200


@app.route("/api/dashboard", methods=["GET"])
@jwt_required()
def dashboard():
    current_user = get_jwt_identity()
    user = db.users.find_one(
        {"email": current_user["email"]}, {"_id": 0, "password": 0}
    )

    if not user:
        return jsonify({"message": "User not found"}), 404

    if current_user["role"] == "admin":
        return jsonify(message=f"Welcome, {user['name']}! You are an Admin.")
    else:
        return jsonify(message=f"Welcome, {user['name']}! You are a User.")


def log_prediction(email, filename, prediction, trojan_type):
    db.trojan_logs.insert_one(
        {
            "email": email,
            "filename": filename,
            "prediction": prediction,
            "trojan_type": trojan_type,
            "timestamp": datetime.now(),
        }
    )


import logging


@app.route("/api/predict-trojan", methods=["POST"])
@jwt_required()
def predict_trojan():
    current_user = get_jwt_identity()
    logging.info(f"User {current_user['email']} is uploading a file...")

    if "file" not in request.files:
        logging.error("No file part in the request.")
        return jsonify({"message": "No file uploaded"}), 400

    file = request.files["file"]

    if file.filename == "":
        logging.error("No file selected.")
        return jsonify({"message": "No file selected"}), 400

    if not allowed_file(file.filename):
        logging.error(f"File extension not allowed for {file.filename}.")
        return (
            jsonify({"message": "Invalid file format. Only CSV files are allowed."}),
            400,
        )

    try:
        logging.info(f"Processing file: {file.filename}")
        filename = secure_filename(file.filename)
        file_path = os.path.join(app.config["UPLOAD_FOLDER"], filename)
        file.save(file_path)

        # Call the Trojan detection logic
        prediction, trojan_type = detect_trojan(file_path)

        if prediction is None:
            return jsonify({"message": "Error processing file."}), 500

        # Convert the prediction (which could be numpy types) to Python native types
        prediction = int(prediction)

        log_prediction(current_user["email"], filename, prediction, trojan_type)

        return (
            jsonify(
                {
                    "prediction": prediction,
                    "trojanType": trojan_type,
                    "filename": filename,
                }
            ),
            200,
        )

    except Exception as e:
        logging.error(f"Error processing file: {str(e)}")
        return jsonify({"message": f"Server error: {str(e)}"}), 500


# Trojan detection logic
def detect_trojan(file_path):
    try:
        # Load data from CSV
        logging.info(f"Loading data from file: {file_path}")
        input_data = pd.read_csv(file_path)

        # Expected feature names from training
        expected_features = [
            "pslist.nproc",
            "pslist.nppid",
            "pslist.avg_threads",
            "pslist.nprocs64bit",
            "pslist.avg_handlers",
            "dlllist.ndlls",
            "dlllist.avg_dlls_per_proc",
            "handles.nhandles",
            "handles.avg_handles_per_proc",
            "handles.nport",
            "handles.nfile",
            "handles.nevent",
            "handles.ndesktop",
            "handles.nkey",
            "handles.nthread",
            "handles.ndirectory",
            "handles.nsemaphore",
            "handles.ntimer",
            "handles.nsection",
            "handles.nmutant",
            "ldrmodules.not_in_load",
            "ldrmodules.not_in_init",
            "ldrmodules.not_in_mem",
            "ldrmodules.not_in_load_avg",
            "ldrmodules.not_in_init_avg",
            "ldrmodules.not_in_mem_avg",
            "malfind.ninjections",
            "malfind.commitCharge",
            "malfind.protection",
            "malfind.uniqueInjections",
            "psxview.not_in_pslist",
            "psxview.not_in_eprocess_pool",
            "psxview.not_in_ethread_pool",
            "psxview.not_in_pspcid_list",
            "psxview.not_in_csrss_handles",
            "psxview.not_in_session",
            "psxview.not_in_deskthrd",
            "psxview.not_in_pslist_false_avg",
            "psxview.not_in_eprocess_pool_false_avg",
            "psxview.not_in_ethread_pool_false_avg",
            "psxview.not_in_pspcid_list_false_avg",
            "psxview.not_in_csrss_handles_false_avg",
            "psxview.not_in_session_false_avg",
            "psxview.not_in_deskthrd_false_avg",
            "modules.nmodules",
            "svcscan.nservices",
            "svcscan.kernel_drivers",
            "svcscan.fs_drivers",
            "svcscan.process_services",
            "svcscan.shared_process_services",
            "svcscan.interactive_process_services",
            "svcscan.nactive",
            "callbacks.ncallbacks",
            "callbacks.nanonymous",
            "callbacks.ngeneric",
        ]

        # Log feature names in input CSV
        logging.info(f"CSV Columns: {input_data.columns.tolist()}")

        # Align the input features with the expected features from training
        input_data_aligned = input_data.reindex(columns=expected_features, fill_value=0)
        logging.info(f"Input data aligned: {input_data_aligned.shape}")

    except Exception as e:
        logging.error(f"Error reading or aligning the file: {str(e)}")
        return None, None

    try:
        # Preprocess the data (scale it)
        logging.info("Scaling input data")
        scaled_data = scaler.transform(input_data_aligned)
        logging.info("Scaling complete")
    except Exception as e:
        logging.error(f"Error preprocessing data: {str(e)}")
        return None, None

    try:
        # Predict using the retrained model
        logging.info("Making predictions")
        rf_prediction = rf_model.predict(scaled_data)
        logging.info(f"Prediction result: {rf_prediction}")
    except Exception as e:
        logging.error(f"Error making prediction: {str(e)}")
        return None, None

    # Example logic to assign Trojan type
    trojan_type = "Remote Access Trojan" if rf_prediction[0] == 1 else "Benign"
    logging.info(f"Trojan Type: {trojan_type}")
    return rf_prediction[0], trojan_type

    try:
        # Load data from CSV
        logging.info(f"Loading data from file: {file_path}")
        input_data = pd.read_csv(file_path)

        # Expected feature names from training
        expected_features = [
            "pslist.nproc",
            "pslist.nppid",
            "pslist.avg_threads",
            "pslist.nprocs64bit",
            "pslist.avg_handlers",
            "dlllist.ndlls",
            "dlllist.avg_dlls_per_proc",
            "handles.nhandles",
            "handles.avg_handles_per_proc",
            "handles.nport",
            "handles.nfile",
            "handles.nevent",
            "handles.ndesktop",
            "handles.nkey",
            "handles.nthread",
            "handles.ndirectory",
            "handles.nsemaphore",
            "handles.ntimer",
            "handles.nsection",
            "handles.nmutant",
            "ldrmodules.not_in_load",
            "ldrmodules.not_in_init",
            "ldrmodules.not_in_mem",
            "ldrmodules.not_in_load_avg",
            "ldrmodules.not_in_init_avg",
            "ldrmodules.not_in_mem_avg",
            "malfind.ninjections",
            "malfind.commitCharge",
            "malfind.protection",
            "malfind.uniqueInjections",
            "psxview.not_in_pslist",
            "psxview.not_in_eprocess_pool",
            "psxview.not_in_ethread_pool",
            "psxview.not_in_pspcid_list",
            "psxview.not_in_csrss_handles",
            "psxview.not_in_session",
            "psxview.not_in_deskthrd",
            "psxview.not_in_pslist_false_avg",
            "psxview.not_in_eprocess_pool_false_avg",
            "psxview.not_in_ethread_pool_false_avg",
            "psxview.not_in_pspcid_list_false_avg",
            "psxview.not_in_csrss_handles_false_avg",
            "psxview.not_in_session_false_avg",
            "psxview.not_in_deskthrd_false_avg",
            "modules.nmodules",
            "svcscan.nservices",
            "svcscan.kernel_drivers",
            "svcscan.fs_drivers",
            "svcscan.process_services",
            "svcscan.shared_process_services",
            "svcscan.interactive_process_services",
            "svcscan.nactive",
            "callbacks.ncallbacks",
            "callbacks.nanonymous",
            "callbacks.ngeneric",
        ]

        # Log feature names in input CSV
        logging.info(f"CSV Columns: {input_data.columns.tolist()}")

        # Align the input features with the expected features from training
        input_data_aligned = input_data.reindex(columns=expected_features, fill_value=0)
        logging.info(f"Input data aligned: {input_data_aligned.shape}")

    except Exception as e:
        logging.error(f"Error reading or aligning the file: {str(e)}")
        return None, None

    try:
        # Preprocess the data (scale it)
        logging.info("Scaling input data")
        scaled_data = scaler.transform(input_data_aligned)
        logging.info("Scaling complete")
    except Exception as e:
        logging.error(f"Error preprocessing data: {str(e)}")
        return None, None

    try:
        # Predict using the retrained model
        logging.info("Making predictions")
        rf_prediction = rf_model.predict(scaled_data)
        logging.info(f"Prediction result: {rf_prediction}")
    except Exception as e:
        logging.error(f"Error making prediction: {str(e)}")
        return None, None

    # Example logic to assign Trojan type
    trojan_type = "Remote Access Trojan" if rf_prediction[0] == 1 else "Benign"
    logging.info(f"Trojan Type: {trojan_type}")

    return rf_prediction[0], trojan_type


@app.route("/api/users", methods=["GET"])
@jwt_required()
def get_users():
    current_user = get_jwt_identity()

    if current_user["role"] != "admin":
        return jsonify({"message": "Unauthorized access"}), 403

    users = list(db.users.find({"role": {"$ne": "admin"}}, {"_id": 0, "password": 0}))

    if not users:
        return jsonify({"message": "No users found"}), 404

    return jsonify(users), 200


@app.route("/api/users/<email>", methods=["PUT"])
@jwt_required()
def update_user(email):
    current_user = get_jwt_identity()

    if current_user["role"] != "admin":
        return jsonify({"message": "Unauthorized access"}), 403

    user = db.users.find_one({"email": email})
    if not user:
        return jsonify({"message": "User not found"}), 404

    updated_data = {
        "name": request.json.get("name", user["name"]),
        "email": request.json.get("email", user["email"]),
        "role": request.json.get("role", user["role"]),
        "disabled": request.json.get("disabled", user.get("disabled", False)),
        "updated_at": datetime.now(),
    }

    db.users.update_one({"email": email}, {"$set": updated_data})
    return jsonify({"message": "User updated successfully"}), 200


@app.route("/api/users/<email>", methods=["DELETE"])
@jwt_required()
def delete_user(email):
    current_user = get_jwt_identity()

    user = db.users.find_one({"email": email})
    if not user or user["role"] == "admin" or user["email"] == current_user["email"]:
        return jsonify({"message": "Cannot delete this user."}), 403

    db.users.delete_one({"email": email})
    return jsonify({"message": "User deleted successfully"}), 200


@app.route("/api/prediction-history", methods=["GET"])
@jwt_required()
def get_prediction_history():
    current_user = get_jwt_identity()

    # If the user is admin, fetch all predictions
    if current_user["role"] == "admin":
        logs = db.trojan_logs.find({}, {"_id": 0})  # Fetch all logs for admins
    else:
        # For regular users, fetch only their own predictions
        logs = db.trojan_logs.find({"email": current_user["email"]}, {"_id": 0})

    log_list = list(logs)

    if not log_list:
        return jsonify({"message": "No prediction history found"}), 404

    return jsonify(log_list), 200


if __name__ == "__main__":
    app.run(debug=True)
