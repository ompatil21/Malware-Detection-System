from flask import Flask, jsonify, request
from flask_bcrypt import Bcrypt
from flask_jwt_extended import (
    JWTManager,
    create_access_token,
    jwt_required,
    get_jwt_identity,
)
from pymongo import MongoClient
from flask_cors import CORS  # Import CORS
from datetime import datetime, timedelta
from werkzeug.utils import secure_filename  # Import this for secure file handling
import os

app = Flask(__name__)

# Allow CORS for all routes, specifically allowing requests from http://localhost:3000
CORS(app, resources={r"/*": {"origins": "http://localhost:3000"}})

# JWT Configuration
app.config["JWT_SECRET_KEY"] = ""  # Replace with your own secret key
app.config["JWT_ACCESS_TOKEN_EXPIRES"] = timedelta(hours=1)  # Token expiry

# Initialize extensions
bcrypt = Bcrypt(app)
jwt = JWTManager(app)

# Connect to MongoDB
client = MongoClient("mongodb://localhost:27017/")
db = client["trojan_detection"]


@app.route("/")
def home():
    return "Welcome to the Flask API!"


@app.route("/api/signup", methods=["POST"])
def signup():
    email = request.json.get("email")  # Get email from request
    password = request.json.get("password")
    role = request.json.get("role")  # "admin" or "user"
    name = request.json.get("name")  # Get user name
    username = request.json.get("username")  # Username is optional or can be secondary

    # Check if the email already exists
    if db.users.find_one({"email": email}):
        return jsonify({"message": "Email already exists"}), 400

    # Hash the password and insert the new user
    hashed_password = bcrypt.generate_password_hash(password).decode("utf-8")
    db.users.insert_one(
        {
            "username": username,  # Can be optional or provided as an alias
            "password": hashed_password,
            "role": role,
            "name": name,
            "email": email,
            "disabled": False,
            "created_at": datetime.now(),
            "updated_at": datetime.now(),
        }
    )

    return jsonify({"message": f"{role.capitalize()} created successfully"}), 201


@app.route("/api/login", methods=["POST"])
def login():
    email = request.json.get("email")  # Use email for login
    password = request.json.get("password")
    role = request.json.get("role")

    # Fetch user from the database based on email and role
    user = db.users.find_one({"email": email, "role": role})

    if not user or not bcrypt.check_password_hash(user["password"], password):
        return jsonify({"message": "Invalid email, password, or role"}), 401

    # Create a JWT token with the email (and optionally role)
    access_token = create_access_token(identity={"email": email, "role": role})
    return jsonify({"token": access_token, "role": role}), 200


@app.route("/api/profile", methods=["GET"])
@jwt_required()
def get_profile():
    current_user = (
        get_jwt_identity()
    )  # Get the identity from the JWT (which contains the email and role)

    # Find the user using the email from the JWT
    user = db.users.find_one(
        {"email": current_user["email"]}, {"_id": 0, "password": 0}
    )

    if not user:
        return jsonify({"message": "User not found"}), 404

    return jsonify(user), 200


@app.route("/api/profile", methods=["PUT"])
@jwt_required()
def update_profile():
    current_user = get_jwt_identity()  # Get the identity from the JWT
    user = db.users.find_one({"username": current_user["username"]})

    if not user:
        return jsonify({"message": "User not found"}), 404

    # Extract the profile fields to update
    updated_data = {
        "name": request.json.get("name", user["name"]),
        "email": request.json.get("email", user["email"]),
        "updated_at": datetime.now(),  # Update the last modified timestamp
    }

    db.users.update_one({"username": current_user["username"]}, {"$set": updated_data})
    return jsonify({"message": "Profile updated successfully"}), 200


@app.route("/api/dashboard", methods=["GET"])
@jwt_required()  # Require valid JWT token to access this route
def dashboard():
    current_user = get_jwt_identity()  # Get the identity from the JWT

    user = db.users.find_one(
        {"email": current_user["email"]}, {"_id": 0, "password": 0}
    )
    if not user:
        return jsonify({"message": "User not found"}), 404

    if current_user["role"] == "admin":
        return jsonify(message=f"Welcome, {user['name']}! You are an Admin.")
    else:
        return jsonify(message=f"Welcome, {user['name']}! You are a User.")


def log_prediction(email, filename, prediction):
    db.trojan_logs.insert_one(
        {
            "email": email,
            "filename": filename,
            "prediction": prediction,
            "timestamp": datetime.now(),
        }
    )


@app.route("/api/predict-trojan", methods=["POST"])
@jwt_required()
def predict_trojan():
    current_user = get_jwt_identity()

    if "file" not in request.files:
        return jsonify({"message": "No file uploaded"}), 400

    file = request.files["file"]

    if file.filename == "":
        return jsonify({"message": "No file selected"}), 400

    # Secure the filename and save the file
    filename = secure_filename(file.filename)
    file_path = os.path.join(app.config["UPLOAD_FOLDER"], filename)
    file.save(file_path)

    # Call the Trojan detection logic (placeholder for now)
    prediction = detect_trojan(file_path)

    # Log the activity in the database
    log_prediction(current_user["email"], filename, prediction)

    # Return the prediction result
    return jsonify({"prediction": prediction}), 200


# File upload configuration
UPLOAD_FOLDER = "uploads"
os.makedirs(UPLOAD_FOLDER, exist_ok=True)
app.config["UPLOAD_FOLDER"] = UPLOAD_FOLDER


# Placeholder function for Trojan detection logic
def detect_trojan(file_path):
    # Replace this with actual malware detection logic
    return "Remote Access Trojan detected"  # Example prediction result


# # Route for predicting Trojan
# @app.route("/api/predict-trojan", methods=["POST"])
# def predict_trojan():
#     if "file" not in request.files:
#         return jsonify({"message": "No file uploaded"}), 400

#     file = request.files["file"]

#     if file.filename == "":
#         return jsonify({"message": "No file selected"}), 400

#     # Secure the filename and save the file
#     filename = secure_filename(file.filename)  # type: ignore
#     file_path = os.path.join(app.config["UPLOAD_FOLDER"], filename)
#     file.save(file_path)

#     # Call the Trojan detection logic (placeholder for now)
#     prediction = detect_trojan(file_path)

#     # Log the activity in the database
#     log_entry = {
#         "email": current_user["email"],  # Log the user's email
#         "filename": filename,
#         "prediction": prediction,
#         "timestamp": datetime.now(),
#     }
#     db.trojan_logs.insert_one(
#         log_entry
#     )  # Insert the log into a new 'trojan_logs' collection

#     # Return the prediction result
#     return jsonify({"prediction": prediction}), 200


@app.route("/api/users", methods=["GET"])
@jwt_required()
def get_users():
    current_user = get_jwt_identity()

    # Ensure only admins can access this endpoint
    if current_user["role"] != "admin":
        return jsonify({"message": "Unauthorized access"}), 403

    # Fetch all users that are not admins (exclude admin accounts)
    users = list(db.users.find({"role": {"$ne": "admin"}}, {"_id": 0, "password": 0}))

    if not users:
        return jsonify({"message": "No users found"}), 404

    return jsonify(users), 200


# Route to update user details (Admin only)
@app.route("/api/users/<email>", methods=["PUT"])
@jwt_required()
def update_user(email):
    current_user = get_jwt_identity()  # Get the identity from the JWT

    # Ensure that only admins can update users
    if current_user["role"] != "admin":
        return (
            jsonify({"message": "Unauthorized access"}),
            403,
        )  # Return a 403 Forbidden if not admin

    user = db.users.find_one({"email": email})
    if not user:
        return jsonify({"message": "User not found"}), 404

    # Proceed with updating the user
    updated_data = {
        "name": request.json.get("name", user["name"]),
        "email": request.json.get("email", user["email"]),
        "role": request.json.get("role", user["role"]),
        "disabled": request.json.get(
            "disabled", user.get("disabled", False)
        ),  # Handle disabled status
        "updated_at": datetime.now(),
    }

    db.users.update_one({"email": email}, {"$set": updated_data})
    return jsonify({"message": "User updated successfully"}), 200


# Route to delete a user (Admin only)
@app.route("/api/users/<email>", methods=["DELETE"])
@jwt_required()
def delete_user(email):
    current_user = get_jwt_identity()

    # Prevent admins from deleting other admins or themselves
    user = db.users.find_one({"email": email})
    if not user or user["role"] == "admin" or user["email"] == current_user["email"]:
        return jsonify({"message": "Cannot delete this user."}), 403

    db.users.delete_one({"email": email})
    return jsonify({"message": "User deleted successfully"}), 200


@app.route("/api/prediction-history", methods=["GET"])
@jwt_required()
def get_prediction_history():
    current_user = get_jwt_identity()  # Get the identity from the JWT

    # If the user is admin, fetch all predictions
    if current_user["role"] == "admin":
        logs = db.predictions.find(
            {}, {"_id": 0}
        )  # Fetch all prediction logs, omit _id
    else:
        # For regular users, fetch only their own predictions
        logs = db.predictions.find({"email": current_user["email"]}, {"_id": 0})

    log_list = list(logs)  # Convert cursor to a list

    if not log_list:
        return jsonify({"message": "No prediction history found"}), 404

    return jsonify(log_list), 200


if __name__ == "__main__":
    app.run(debug=True)
