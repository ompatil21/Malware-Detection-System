from flask import Flask, jsonify, request
from flask_bcrypt import Bcrypt
from flask_jwt_extended import (
    JWTManager,
    create_access_token,
    jwt_required,
    get_jwt_identity,
)
from pymongo import MongoClient
from flask_cors import CORS  # Import CORS
from datetime import datetime, timedelta
from werkzeug.utils import secure_filename  # Import this for secure file handling
import os

app = Flask(__name__)

# Allow CORS for all routes, specifically allowing requests from http://localhost:3000
CORS(app, resources={r"/*": {"origins": "http://localhost:3000"}})

# JWT Configuration
app.config["JWT_SECRET_KEY"] = ""  # Replace with your own secret key
app.config["JWT_ACCESS_TOKEN_EXPIRES"] = timedelta(hours=1)  # Token expiry

# Initialize extensions
bcrypt = Bcrypt(app)
jwt = JWTManager(app)

# Connect to MongoDB
client = MongoClient("mongodb://localhost:27017/")
db = client["trojan_detection"]


@app.route("/")
def home():
    return "Welcome to the Flask API!"


# Route for User Signup
@app.route("/api/signup", methods=["POST"])
def signup():
    username = request.json.get("username")
    password = request.json.get("password")
    role = request.json.get("role")  # "admin" or "user"

    if db.users.find_one({"username": username}):
        return jsonify({"message": "User already exists"}), 400

    hashed_password = bcrypt.generate_password_hash(password).decode("utf-8")
    db.users.insert_one(
        {"username": username, "password": hashed_password, "role": role}
    )

    return jsonify({"message": f"{role.capitalize()} created successfully"}), 201


# Route for Admin/User Login
@app.route("/api/login", methods=["POST"])
def login():
    username = request.json.get("username")
    password = request.json.get("password")
    role = request.json.get("role")

    # Fetch user from the database based on username and role
    user = db.users.find_one({"username": username, "role": role})

    if not user or not bcrypt.check_password_hash(user["password"], password):
        return jsonify({"message": "Invalid username, password, or role"}), 401

    # Create a JWT token with the role (admin or user)
    access_token = create_access_token(identity={"username": username, "role": role})
    return jsonify({"token": access_token, "role": role}), 200


# Protected route for dashboard (both admin and user)
@app.route("/api/dashboard", methods=["GET"])
@jwt_required()  # Require valid JWT token to access this route
def dashboard():
    current_user = get_jwt_identity()  # Get the identity from the JWT

    if current_user["role"] == "admin":
        return jsonify(
            message=f"Welcome, {current_user['username']}! You are an Admin."
        )
    else:
        return jsonify(message=f"Welcome, {current_user['username']}! You are a User.")


def log_prediction(filename, prediction):
    db.predictions.insert_one(
        {"filename": filename, "prediction": prediction, "timestamp": datetime.now()}
    )


# File upload configuration
UPLOAD_FOLDER = "uploads"
os.makedirs(UPLOAD_FOLDER, exist_ok=True)
app.config["UPLOAD_FOLDER"] = UPLOAD_FOLDER


# Placeholder function for Trojan detection logic
def detect_trojan(file_path):
    # Replace this with actual malware detection logic
    return "Remote Access Trojan detected"  # Example prediction result


# Route for predicting Trojan
@app.route("/api/predict-trojan", methods=["POST"])
def predict_trojan():
    if "file" not in request.files:
        return jsonify({"message": "No file uploaded"}), 400

    file = request.files["file"]

    if file.filename == "":
        return jsonify({"message": "No file selected"}), 400

    # Secure the filename and save the file
    filename = secure_filename(file.filename)  # type: ignore
    file_path = os.path.join(app.config["UPLOAD_FOLDER"], filename)
    file.save(file_path)

    # Call the Trojan detection logic (placeholder for now)
    prediction = detect_trojan(file_path)

    # Return the prediction result
    return jsonify({"prediction": prediction}), 200


if __name__ == "__main__":
    app.run(debug=True)
