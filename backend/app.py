from flask import Flask, jsonify, request
from flask_bcrypt import Bcrypt
from flask_jwt_extended import (
    JWTManager,
    create_access_token,
    jwt_required,
    get_jwt_identity,
)
from pymongo import MongoClient
from flask_cors import CORS
from datetime import datetime, timedelta
from werkzeug.utils import secure_filename
import os
import joblib
import pandas as pd
from sklearn.preprocessing import StandardScaler


app = Flask(__name__)

# Allow CORS for all routes, specifically allowing requests from http://localhost:3000
CORS(app, resources={r"/*": {"origins": "http://localhost:3000"}})

# JWT Configuration
app.config["JWT_SECRET_KEY"] = ""
app.config["JWT_ACCESS_TOKEN_EXPIRES"] = timedelta(hours=1)

# Initialize extensions
bcrypt = Bcrypt(app)
jwt = JWTManager(app)

# Connect to MongoDB
client = MongoClient("mongodb://localhost:27017/")
db = client["trojan_detection"]

# File upload configuration
UPLOAD_FOLDER = "uploads"
os.makedirs(UPLOAD_FOLDER, exist_ok=True)
app.config["UPLOAD_FOLDER"] = UPLOAD_FOLDER

# Load the trained models and scaler
rf_model = joblib.load("rf_model.pkl")  # Load Random Forest model
gb_model = joblib.load("gb_model.pkl")  # Load Gradient Boosting model
scaler = joblib.load("scaler.pkl")  # Load the scaler

ALLOWED_EXTENSIONS = {"csv"}


def allowed_file(filename):
    return "." in filename and filename.rsplit(".", 1)[1].lower() in ALLOWED_EXTENSIONS


@app.route("/")
def home():
    return "Welcome to the Flask API!"


@app.route("/api/signup", methods=["POST"])
def signup():
    email = request.json.get("email")
    password = request.json.get("password")
    role = request.json.get("role")
    name = request.json.get("name")
    username = request.json.get("username")

    if db.users.find_one({"email": email}):
        return jsonify({"message": "Email already exists"}), 400

    hashed_password = bcrypt.generate_password_hash(password).decode("utf-8")
    db.users.insert_one(
        {
            "username": username,
            "password": hashed_password,
            "role": role,
            "name": name,
            "email": email,
            "disabled": False,
            "created_at": datetime.now(),
            "updated_at": datetime.now(),
        }
    )

    return jsonify({"message": f"{role.capitalize()} created successfully"}), 201


@app.route("/api/login", methods=["POST"])
def login():
    email = request.json.get("email")
    password = request.json.get("password")
    role = request.json.get("role")

    user = db.users.find_one({"email": email, "role": role})

    if not user or not bcrypt.check_password_hash(user["password"], password):
        return jsonify({"message": "Invalid email, password, or role"}), 401

    access_token = create_access_token(identity={"email": email, "role": role})
    return jsonify({"token": access_token, "role": role}), 200


@app.route("/api/profile", methods=["GET"])
@jwt_required()
def get_profile():
    current_user = get_jwt_identity()
    user = db.users.find_one(
        {"email": current_user["email"]}, {"_id": 0, "password": 0}
    )

    if not user:
        return jsonify({"message": "User not found"}), 404

    return jsonify(user), 200


@app.route("/api/profile", methods=["PUT"])
@jwt_required()
def update_profile():
    current_user = get_jwt_identity()
    user = db.users.find_one({"username": current_user["username"]})

    if not user:
        return jsonify({"message": "User not found"}), 404

    updated_data = {
        "name": request.json.get("name", user["name"]),
        "email": request.json.get("email", user["email"]),
        "updated_at": datetime.now(),
    }

    db.users.update_one({"username": current_user["username"]}, {"$set": updated_data})
    return jsonify({"message": "Profile updated successfully"}), 200


@app.route("/api/dashboard", methods=["GET"])
@jwt_required()
def dashboard():
    current_user = get_jwt_identity()
    user = db.users.find_one(
        {"email": current_user["email"]}, {"_id": 0, "password": 0}
    )

    if not user:
        return jsonify({"message": "User not found"}), 404

    if current_user["role"] == "admin":
        return jsonify(message=f"Welcome, {user['name']}! You are an Admin.")
    else:
        return jsonify(message=f"Welcome, {user['name']}! You are a User.")


def log_prediction(email, filename, prediction, trojan_type):
    db.trojan_logs.insert_one(
        {
            "email": email,
            "filename": filename,
            "prediction": prediction,
            "trojan_type": trojan_type,
            "timestamp": datetime.now(),
        }
    )


import logging


@app.route("/api/predict-trojan", methods=["POST"])
@jwt_required()
def predict_trojan():
    current_user = get_jwt_identity()

    logging.info(f"User {current_user['email']} is uploading a file...")

    if "file" not in request.files:
        logging.error("No file part in the request.")
        return jsonify({"message": "No file uploaded"}), 400

    file = request.files["file"]

    if file.filename == "":
        logging.error("No file selected.")
        return jsonify({"message": "No file selected"}), 400

    if not allowed_file(file.filename):
        logging.error(f"File extension not allowed for {file.filename}.")
        return (
            jsonify({"message": "Invalid file format. Only CSV files are allowed."}),
            400,
        )

    logging.info(f"Processing file: {file.filename}")

    # Secure the filename and save the file
    filename = secure_filename(file.filename)
    file_path = os.path.join(app.config["UPLOAD_FOLDER"], filename)
    file.save(file_path)

    # Call the Trojan detection logic
    prediction, trojan_type = detect_trojan(file_path)

    if not prediction:
        return jsonify({"message": "Error processing file."}), 500

    log_prediction(current_user["email"], filename, prediction, trojan_type)

    return (
        jsonify(
            {"prediction": prediction, "trojanType": trojan_type, "filename": filename}
        ),
        200,
    )


def detect_trojan(file_path):
    try:
        # Load data from CSV
        input_data = pd.read_csv(file_path)

        # Get the features that the model was trained on
        expected_features = rf_model.feature_names_in_

        # Align the input features with the expected features
        # Fill missing features with 0 and drop extra features
        input_data_aligned = input_data.reindex(columns=expected_features, fill_value=0)

    except Exception as e:
        return f"Error reading or aligning the file: {str(e)}", None

    try:
        # Preprocess the data
        scaled_data = scaler.transform(input_data_aligned)
    except Exception as e:
        return f"Error preprocessing data: {str(e)}", None

    # Predict using the models
    rf_prediction = rf_model.predict(scaled_data)
    gb_prediction = gb_model.predict(scaled_data)

    # Perform majority voting
    final_predictions = [
        majority_voting([rf, gb]) for rf, gb in zip(rf_prediction, gb_prediction)
    ]

    # Example logic to assign Trojan type
    trojan_type = (
        "Remote Access Trojan" if "Malicious" in final_predictions else "Benign"
    )

    return final_predictions[0], trojan_type


def majority_voting(predictions):
    return max(set(predictions), key=predictions.count)


@app.route("/api/users", methods=["GET"])
@jwt_required()
def get_users():
    current_user = get_jwt_identity()

    if current_user["role"] != "admin":
        return jsonify({"message": "Unauthorized access"}), 403

    users = list(db.users.find({"role": {"$ne": "admin"}}, {"_id": 0, "password": 0}))

    if not users:
        return jsonify({"message": "No users found"}), 404

    return jsonify(users), 200


@app.route("/api/users/<email>", methods=["PUT"])
@jwt_required()
def update_user(email):
    current_user = get_jwt_identity()

    if current_user["role"] != "admin":
        return jsonify({"message": "Unauthorized access"}), 403

    user = db.users.find_one({"email": email})
    if not user:
        return jsonify({"message": "User not found"}), 404

    updated_data = {
        "name": request.json.get("name", user["name"]),
        "email": request.json.get("email", user["email"]),
        "role": request.json.get("role", user["role"]),
        "disabled": request.json.get("disabled", user.get("disabled", False)),
        "updated_at": datetime.now(),
    }

    db.users.update_one({"email": email}, {"$set": updated_data})
    return jsonify({"message": "User updated successfully"}), 200


@app.route("/api/users/<email>", methods=["DELETE"])
@jwt_required()
def delete_user(email):
    current_user = get_jwt_identity()

    user = db.users.find_one({"email": email})
    if not user or user["role"] == "admin" or user["email"] == current_user["email"]:
        return jsonify({"message": "Cannot delete this user."}), 403

    db.users.delete_one({"email": email})
    return jsonify({"message": "User deleted successfully"}), 200


@app.route("/api/prediction-history", methods=["GET"])
@jwt_required()
def get_prediction_history():
    current_user = get_jwt_identity()

    # If the user is admin, fetch all predictions
    if current_user["role"] == "admin":
        logs = db.trojan_logs.find({}, {"_id": 0})  # Fetch all logs for admins
    else:
        # For regular users, fetch only their own predictions
        logs = db.trojan_logs.find({"email": current_user["email"]}, {"_id": 0})

    log_list = list(logs)

    if not log_list:
        return jsonify({"message": "No prediction history found"}), 404

    return jsonify(log_list), 200


if __name__ == "__main__":
    app.run(debug=True)
